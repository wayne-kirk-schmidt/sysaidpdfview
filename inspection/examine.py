"""
Collection of functions for the examine verb in sysaidpdfview
"""
import re
from pathlib import Path
from typing import List, Dict, Any, Optional

import pdfplumber

from models import InspectResult

# ============================================================
# Constants - By inspection and Verification
# ============================================================

KEY_X_MIN = 39
KEY_X_MAX = 150
VALUE_X_MIN = 151
LINE_TOLERANCE = 3

NO_DATA_SENTINEL = "NO_DATA"

# These are noise lines — discard, but NEVER reset state
IGNORE_KEYS = {
    "Generated by SysAid",
}

PAGE_RE = re.compile(r"^Page\s+\d+\s+of\s+\d+$", re.IGNORECASE)

# Header line: e.g. "Incident 499457"
# (Kept for compatibility; TicketType now comes from first calibration line,
#  and TicketNumber is learned from the '#' line when present.)
TICKET_HEADER_RE = re.compile(r"^(?P<type>[A-Za-z]+)\s+(?P<number>\d+)\b")

# ============================================================
# Calibration regex
# TicketType is derived ONLY from the first calibration line:
#   - first contiguous alphabetic token (letters only)
# ============================================================
CALIBRATED_TYPE_RE = re.compile(r"^(?P<type>[A-Za-z]+)")

# Extract digits (handles commas/spaces if any)
DIGITS_RE = re.compile(r"(?P<num>\d+)")

# ============================================================
# Core Examine extraction
# ============================================================

# pylint: disable=too-many-locals,too-many-branches,too-many-statements
def extract_records(result: InspectResult) -> List[Dict[str, Any]]:
    """
    Layout-driven key/value extraction.
    Deterministic model:

    Case 1: key + value   -> create new record
    Case 2: key + no val  -> create new record with NO_DATA
    Case 3: no key + val  -> append to current key

    Only keys create context.
    """

    pdf_path = Path(result.document.path)
    output: List[Dict[str, Any]] = []

    # Cursor: the most recent key record
    last_record: Optional[Dict[str, Any]] = None

    ticket_type: Optional[str] = None
    ticket_number: Optional[str] = None
    ticket_emitted = False

    with pdfplumber.open(pdf_path) as pdf:
        for page_idx, page in enumerate(pdf.pages, start=1):

            # ==================================================
            # INITIAL CALIBRATION (once per document)
            # ==================================================
            if ticket_type is None:
                raw_text = page.extract_text() or ""
                lines = [ln.strip() for ln in raw_text.splitlines() if ln.strip()]
                if lines:
                    first_line = lines[0]

                    # TicketType = first contiguous alphabetic token
                    mtype = CALIBRATED_TYPE_RE.match(first_line)
                    if mtype:
                        ticket_type = mtype.group("type")

                    # Legacy fallback: may give number for clean Incident headers
                    m = TICKET_HEADER_RE.match(first_line)
                    if m and ticket_number is None:
                        ticket_number = m.group("number")

            words = page.extract_words(use_text_flow=True)

            # ==================================================
            # Group words into visual lines
            # ==================================================
            visual_lines: List[Dict[str, Any]] = []
            for w in words:
                for line in visual_lines:
                    if abs(line["top"] - w["top"]) <= LINE_TOLERANCE:
                        line["words"].append(w)
                        break
                else:
                    visual_lines.append({"top": w["top"], "words": [w]})

            # ==================================================
            # Process each visual line
            # ==================================================
            for line in visual_lines:
                key_parts: List[str] = []
                value_parts: List[str] = []

                for w in sorted(line["words"], key=lambda x: x["x0"]):
                    if KEY_X_MIN <= w["x0"] <= KEY_X_MAX:
                        key_parts.append(w["text"])
                    elif w["x0"] >= VALUE_X_MIN:
                        value_parts.append(w["text"])

                has_key = bool(key_parts)
                has_value = bool(value_parts)

                key_text = " ".join(key_parts).strip()
                value_text = " ".join(value_parts).strip()

                # --------------------------------------------------
                # NORMALIZATION
                #
                # If text lands in the key column but has NO value
                # partner, it is NOT a key. It is continuation text
                # that drifted left.
                # --------------------------------------------------
                if has_key and not has_value:
                    has_key = False
                    has_value = True
                    value_text = key_text
                    key_text = ""

                # ==================================================
                # Case 1: KEY + VALUE
                # ==================================================
                if has_key and has_value:

                    # Discard noise — DO NOT reset state
                    if key_text in IGNORE_KEYS:
                        continue

                    # Learn TicketNumber from the '#' line (authoritative)
                    if key_text == "#" and ticket_number is None:
                        md = DIGITS_RE.search(value_text.replace(",", ""))
                        if md:
                            ticket_number = md.group("num")

                    # Normalize standalone "#"
                    if key_text == "#" and ticket_number:
                        if not ticket_emitted and ticket_type:
                            output.append({
                                "page": page_idx,
                                "key": "TicketType",
                                "value": ticket_type,
                            })
                        record = {
                            "page": page_idx,
                            "key": "TicketNumber",
                            "value": ticket_number,
                        }
                        output.append(record)
                        last_record = record
                        ticket_emitted = True
                        continue

                    record = {
                        "page": page_idx,
                        "key": key_text,
                        "value": value_text,
                    }
                    output.append(record)
                    last_record = record
                    continue

                # ==================================================
                # Case 2: KEY + NO VALUE
                # ==================================================
                if has_key and not has_value:

                    # Discard noise — DO NOT reset state
                    if key_text in IGNORE_KEYS:
                        continue

                    if key_text == "#" and ticket_number:
                        if not ticket_emitted and ticket_type:
                            output.append({
                                "page": page_idx,
                                "key": "TicketType",
                                "value": ticket_type,
                            })
                        record = {
                            "page": page_idx,
                            "key": "TicketNumber",
                            "value": ticket_number,
                        }
                        output.append(record)
                        last_record = record
                        ticket_emitted = True
                        continue

                    record = {
                        "page": page_idx,
                        "key": key_text,
                        "value": NO_DATA_SENTINEL,
                    }
                    output.append(record)
                    last_record = record
                    continue

                # ==================================================
                # Case 3: NO KEY + VALUE
                # ==================================================
                if not has_key and has_value:
                    if PAGE_RE.match(value_text):
                        continue

                    # Values always belong to the current key
                    if last_record is not None:
                        last_record["value"] += "\n" + value_text
                    continue

                # else: ignore noise

    return output


# ============================================================
# Examine views
# ============================================================

def extract_keys(result: InspectResult) -> List[str]:
    """
    Ordered KEYS only, exactly as discovered.
    """
    return [r["key"] for r in extract_records(result)]


def print_keys(result: InspectResult) -> None:
    """
    Verbose diagnostic: print extracted KEYS.
    """
    keys = extract_keys(result)
    print("\n=== EXTRACTED KEYS ===")
    for idx, key in enumerate(keys):
        print(f"{idx:03d}: {key}")

