"""
Collection of functions for the examine verb in sysaidpdfview
"""
import re
from pathlib import Path
from typing import List, Dict, Any, Optional

import pdfplumber

from models import InspectResult

# ============================================================
# Constants - By inspection and Verification
# ============================================================

KEY_X_MIN = 39
KEY_X_MAX = 150
VALUE_X_MIN = 151
LINE_TOLERANCE = 3

NO_DATA_SENTINEL = "NO_DATA"

IGNORE_KEYS = {
    "Generated by SysAid",
}

PAGE_RE = re.compile(r"^Page\s+\d+\s+of\s+\d+$", re.IGNORECASE)

# Header line: e.g. "Incident 499457"
TICKET_HEADER_RE = re.compile(r"^(?P<type>[A-Za-z]+)\s+(?P<number>\d+)\b")

# ============================================================
# Core Examine extraction 
# ============================================================

# pylint: disable=too-many-locals,too-many-branches,too-many-statements
def extract_records(result: InspectResult) -> List[Dict[str, Any]]:
    """
    Layout-driven key/value extraction.
    Direct transplant of testme.6.py logic,
    with deterministic normalization of '#' into:
      - TicketType
      - TicketNumber
    """

    pdf_path = Path(result.document.path)
    output: List[Dict[str, Any]] = []

    last_record: Optional[Dict[str, Any]] = None
    last_record_appendable = False

    ticket_type: Optional[str] = None
    ticket_number: Optional[str] = None
    ticket_emitted = False

    with pdfplumber.open(pdf_path) as pdf:
        for page_idx, page in enumerate(pdf.pages, start=1):

            # ==================================================
            # Capture ticket header once at the top of document
            # ==================================================
            if ticket_type is None:
                raw_text = page.extract_text() or ""
                lines = raw_text.strip().splitlines()
                if lines:
                    m = TICKET_HEADER_RE.match(lines[0].strip())
                    if m:
                        ticket_type = m.group("type")
                        ticket_number = m.group("number")

            words = page.extract_words(use_text_flow=True)

            # ==================================================
            # Group words into visual groups within a line
            # ==================================================
            visual_lines: List[Dict[str, Any]] = []
            for w in words:
                for line in visual_lines:
                    if abs(line["top"] - w["top"]) <= LINE_TOLERANCE:
                        line["words"].append(w)
                        break
                else:
                    visual_lines.append({"top": w["top"], "words": [w]})

            # ==================================================
            # Process each group of words or "line"
            # ==================================================
            for line in visual_lines:
                key_parts: List[str] = []
                value_parts: List[str] = []

                for w in sorted(line["words"], key=lambda x: x["x0"]):
                    if KEY_X_MIN <= w["x0"] <= KEY_X_MAX:
                        key_parts.append(w["text"])
                    elif w["x0"] >= VALUE_X_MIN:
                        value_parts.append(w["text"])

                has_key = bool(key_parts)
                has_value = bool(value_parts)

                key_text = " ".join(key_parts).strip()
                value_text = " ".join(value_parts).strip()

                # ==== Case 1: key + value ====
                if has_key and has_value:
                    if key_text in IGNORE_KEYS:
                        last_record = None
                        last_record_appendable = False
                        continue

                    # Normalize standalone "#"
                    if key_text == "#" and ticket_number:
                        if not ticket_emitted and ticket_type:
                            output.append({
                                "page": page_idx,
                                "key": "TicketType",
                                "value": ticket_type,
                            })
                        record = {
                            "page": page_idx,
                            "key": "TicketNumber",
                            "value": ticket_number,
                        }
                        output.append(record)
                        last_record = record
                        last_record_appendable = False
                        ticket_emitted = True
                        continue

                    record = {
                        "page": page_idx,
                        "key": key_text,
                        "value": value_text,
                    }
                    output.append(record)
                    last_record = record
                    last_record_appendable = True
                    continue

                # ==== Case 3: key only ====
                if has_key and not has_value:
                    if key_text in IGNORE_KEYS:
                        last_record = None
                        last_record_appendable = False
                        continue

                    if key_text == "#" and ticket_number:
                        if not ticket_emitted and ticket_type:
                            output.append({
                                "page": page_idx,
                                "key": "TicketType",
                                "value": ticket_type,
                            })
                        record = {
                            "page": page_idx,
                            "key": "TicketNumber",
                            "value": ticket_number,
                        }
                        output.append(record)
                        last_record = record
                        last_record_appendable = False
                        ticket_emitted = True
                        continue

                    record = {
                        "page": page_idx,
                        "key": key_text,
                        "value": NO_DATA_SENTINEL,
                    }
                    output.append(record)
                    last_record = record
                    last_record_appendable = False
                    continue

                # ==== Case 2: value continuation ====
                if not has_key and has_value:
                    if PAGE_RE.match(value_text):
                        continue

                    if last_record is not None and last_record_appendable:
                        last_record["value"] += "\n" + value_text
                    continue

                # else: ignore

    return output

# ============================================================
# Examine views
# ============================================================

def extract_keys(result: InspectResult) -> List[str]:
    """
    Ordered KEYS only, exactly as discovered.
    """
    return [r["key"] for r in extract_records(result)]


def print_keys(result: InspectResult) -> None:
    """
    Verbose diagnostic: print extracted KEYS.
    """
    keys = extract_keys(result)
    print("\n=== EXTRACTED KEYS ===")
    for idx, key in enumerate(keys):
        print(f"{idx:03d}: {key}")
